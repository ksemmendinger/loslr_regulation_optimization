# import libraries
import os
import sys
import numpy as np
import pandas as pd
from glob import glob
from pathlib import Path
from os.path import exists

# set working directory
wd = "/Users/kylasemmendinger/Box/Plan_2014/optimization/output"
os.chdir(wd)

# names of objectives
pis = [
    "Coastal Impacts: Upstream Buildings Impacted (#)",
    "Coastal Impacts: Downstream Buildings Impacted (#)",
    "Commercial Navigation: Ontario + Seaway + Montreal Transportation Costs ($)",
    "Hydropower: Moses-Saunders + Niagara Energy Value ($)",
    "Meadow Marsh: Area (ha)",
    "Muskrat House Density (#/ha)",
    "Recreational Boating: Impact Costs ($)",
]

# -----------------------------------------------------------------------------
# find nondominated policies
# -----------------------------------------------------------------------------

# find non dominated solutions across all pareto fronts generated by all seeds
def is_pareto_efficient(costs, return_mask=True):

    # find the pareto-efficient points
    # costs: (n_points, n_costs) array
    # return_mask: True to return a mask
    # return: array of indices of pareto-efficient points. if return_mask is
    # True, this will be an (n_points, ) boolean array. otherwise it will be
    # a (n_efficient_points, ) integer array of indices

    is_efficient = np.arange(costs.shape[0])
    n_points = costs.shape[0]

    # next index in the is_efficient array to search for
    next_point_index = 0
    while next_point_index < len(costs):
        nondominated_point_mask = np.any(costs < costs[next_point_index], axis=1)
        nondominated_point_mask[next_point_index] = True
        # remove dominated points
        is_efficient = is_efficient[nondominated_point_mask]
        costs = costs[nondominated_point_mask]
        next_point_index = np.sum(nondominated_point_mask[:next_point_index]) + 1
    if return_mask:
        is_efficient_mask = np.zeros(n_points, dtype=bool)
        is_efficient_mask[is_efficient] = True
        return is_efficient_mask
    else:
        return is_efficient


# -----------------------------------------------------------------------------
# load nondominated policies across all forecast leadtimes and skills
# -----------------------------------------------------------------------------

path = "data/*/NonDominatedPolicies*.txt"
filelist = [f for f in glob(path, recursive=True) if os.path.isfile(f)]
filelist = [i for i in filelist if "baseline" not in i]

pf = []

for fn in filelist:

    tmpPF = pd.read_csv(fn, sep="\t")
    pf.append(tmpPF)

pf = pd.concat(pf).reset_index(drop=True)

# extract objectives
objs = pf[pis].to_numpy(dtype="float")

# find reference set
refsetInd = is_pareto_efficient(objs, return_mask=True)
refsetInd = pd.Series(refsetInd)
refsetUpdated = pf[refsetInd].reset_index(drop=True)

# save updated reference set
refsetUpdated.to_csv(
    "data/NonDominatedPolicies.txt",
    sep="\t",
    header=True,
    index=False,
)
